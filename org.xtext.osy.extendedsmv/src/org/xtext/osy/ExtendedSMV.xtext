grammar org.xtext.osy.ExtendedSMV with org.eclipse.xtext.common.Terminals

import 'http://www.eclipse.org/emf/2002/Ecore' as ecore

generate extendedSMV "http://www.xtext.org/osy/ExtendedSMV"

Model:
	(modules += Module)*
;

Module:
	'MODULE' name=IDENTIFIER
	// @YE: the params' expression is included in parentheses with question mark,
	// because parameter list may be empty like in this example: Module A()  
	('(' ((params += Parameter) (',' params += Parameter)*)? ')')?
	(sections += Section)*
;

Parameter:
	name = IDENTIFIER
;

Section:
	VariableDeclaration | Assignments | Transactions | DefineDeclaration | Constraints
	| LTLSpecification | CTLSpecification //| Comments
;

VariableDeclaration:
  {VariableDeclaration}
  'VAR' (variables+=DeclaredVariable)*
;

DeclaredVariable returns Variable:
  name=IDENTIFIER ':' type=Type semicolon?=';'?
;

Type: 
  SimpleTypeSpecifier
  | ModuleTypeSpecifier 
;

SimpleTypeSpecifier:
	{BooleanType} 'boolean'
	| {WordType} ('word' '[' wordINT=INT ']') 
	| {UnsignedWordType} ('unsigned' 'word' '[' uWordINT=INT ']')
	| {SignedWordType} ('signed word' '[' signedINT=INT ']')
	| {EnumType} '{' literals+=EmunLiteral (',' literals+=EmunLiteral)* '}'
	| {IntervalType} lower=INT '..' upper=INT
	| {ArrayType} 'array' lower=INT '..' upper=INT 'of' type=SimpleTypeSpecifier
;

ModuleTypeSpecifier:
  {SyncrProcessType} module=[Module|IDENTIFIER] ("(" params+=SimpleExpression ("," params+=SimpleExpression)* ")")?
  | {AsyncrProcessType} "process" module=[Module|IDENTIFIER] ("(" params+=SimpleExpression ("," params+=SimpleExpression)* ")")?
;

EmunLiteral:
	EnumVariable
	| IntegerConstant
	| BooleanConstant
;

EnumVariable:  
  name=IDENTIFIER
;

IntegerConstant returns Expression:
  {IntegerConstant} constant=INT
;

DefineDeclaration:
  {DefineDeclaration}
  'DEFINE' (definitions+=Definition)*
;

Constraints:  
  feature=BasicOpConstraints expression=SimpleExpression semicolon?=';'?
;

BasicOpConstraints:
  'INIT'|'INVAR'|'TRANS'|'FAIRNESS'|'JUSTICE';


 

//InitConstraint:
//	'INIT' SimpleExpression ';'?
//;
//
//InVarConstraint:
//	'INVAR' SimpleExpression ';'?
//;


//InVarSpecification:
//	'INVARSPEC' SimpleExpression ';'
//;
//
//ISADecleration: //TODO: this is derecated maybe we should remove this!
//	 'ISA' IDENTIFIER
//;
//
//ComputeSpecification:
//	'COMPUTE' ComputeExpression
//;

//ComputeExpression:
//	'MIN' '[' RTCTLExpression ',' RTCTLExpression ']' |
//	'MAX' '[' RTCTLExpression ',' RTCTLExpression ']'
//;
//
//RTCTLExpression:
//	CTLExpression | 'EBF' Range RTCTLExpression | 'ABF' Range RTCTLExpression |
//	'EBG' Range RTCTLExpression | 'ABG' Range RTCTLExpression |
//	'A' '[' RTCTLExpression 'BU' Range RTCTLExpression  ']' |
//	'E' '[' RTCTLExpression 'BU' Range RTCTLExpression  ']' 
//;

Range: 
	IntegerNumber '..' IntegerNumber
;

//FairnessConsratint:
//	'FAIRNESS' SimpleExpression ';'? | 'JUSTICE' SimpleExpression ';'? |
//	'COMPASSION' '(' SimpleExpression ',' SimpleExpression ')' ';'?
//;

SimpleExpression returns Expression: //TODO: Note that simple expressions cannot contain next operators
	BasicExpression
;

//BasicExpression:
//	Constant | VariableIdentifier | DefineIdentifier |
//	'(' BasicExpression ')' | '!' BasicExpression | BasicExpression '&' BasicExpression |
//	BasicExpression '|' BasicExpression | BasicExpression 'xor' BasicExpression | 
//	BasicExpression 'xnor' BasicExpression | BasicExpression '->' BasicExpression |
//	BasicExpression '<->' BasicExpression | BasicExpression '=' BasicExpression |
//	BasicExpression '!=' BasicExpression | BasicExpression '<' BasicExpression | 
//	BasicExpression '>' BasicExpression | BasicExpression '<=' BasicExpression | 
//	BasicExpression '>=' BasicExpression | '-' BasicExpression | 
//	BasicExpression '+' BasicExpression | BasicExpression '-' BasicExpression |
//	BasicExpression '*' BasicExpression  | BasicExpression '/' BasicExpression |
//	BasicExpression 'mod' BasicExpression | BasicExpression '>>' BasicExpression |
//	BasicExpression '<<' BasicExpression | BasicExpression '[' Index ']' |
//	BasicExpression '[' IntegerNumber ':' IntegerNumber ']' |
//	BasicExpression '::' BasicExpression | 
//	'word1 (' BasicExpression ')' | 'bool (' BasicExpression ')' | 'toint (' BasicExpression ')' | 
//	'signed (' BasicExpression ')' | 'unsigned (' BasicExpression ')' | 
//	'extend (' BasicExpression ',' BasicExpression ')' | 'resize (' BasicExpression ',' BasicExpression ')' |
//	BasicExpression 'union' BasicExpression | '{' SetBodyExpr '}' | BasicExpression 'in' BasicExpression |
//	BasicExpression '?' BasicExpression ':' BasicExpression | 'count (' BasicExpression ')' |
//	CaseExpr | 'next' '(' BasicExpression ')'    
//		
//;

//BasicExpression returns Expression:
//	AND
//;
//
//
//AND returns Expression:
//	OR ({BinaryExpression.left=current} feature=AND_SYMBOL right=OR)*
//;
//
//AND_SYMBOL:
//	'&'
//;
//
//OR:
//	'l'
//;

SetBodyExpression returns Expression:
  {SetBodyExpression}
  '{' expressions+=SimpleExpression (',' expressions+=SimpleExpression)* '}'
  //'{' expressions+=IDENTIFIER (',' expressions+=IDENTIFIER)* '}'
;

//Constant:
//	BooleanConstant | IntegerConstant | SymbolicConstant | WordConstant | RangeConstant   
//;

//BooleanConstant: 
//	BOOL
//;

//IntegerConstant: 
//	IntegerNumber
//;

SymbolicConstant:
	IDENTIFIER
;

//WordConstant:
//	'0' WordSignSpecifier? WordBase WordWidth? '_' WordValue
//;

WordSignSpecifier:
	'u' | 's'
;

WordBase:
	'b' | 'B' | 'o' | 'O' | 'd' | 'D' | 'h' | 'H'
;

WordWidth:
	IntegerNumber //TODO: must be possitive - check that this if possitive with a validator rule
;

//WordValue:
//	HexDigit | WordValueTAG 
//;
//
//WordValueTAG:
//	HexDigit WordValue
//;

//HexDigit:
//	'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' |
//	'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D' |
//	'E' | 'F' 
//;

RangeConstant:
	IntegerNumber '..' IntegerNumber
;

IntegerNumber:
	INT // TODO: this is not exactly an int - CHECK THIS PLEASE
;

// DIGIT: 
//	('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' |'9')
//;

DefineIdentifier:
	ComplexIdentifier
;

VariableIdentifier returns Expression:
	ComplexIdentifier
;

//ComplexIdentifier returns Expression:
//	('self' | IDENTIFIER) ComplexIdentifierTag?
//	//IDENTIFIER | ComplexIdentifier '.' IDENTIFIER // | ComplexIdentifier '[' SimpleExpression ']' | 'self'
//	;
//
//ComplexIdentifierTag returns Expression:
//	('.'IDENTIFIER) ComplexIdentifierTag? | '[' SimpleExpression ']'
//;

terminal IDENTIFIER:
	//IDENTIFIER_FIRST_CHARACTER | Identifier IdentifierConsecutiveCharacter
	(('a' .. 'z') |( 'A' .. 'Z') | '_') (('a' .. 'z') | ('A' .. 'Z') | '_' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' |'9' | '$' | '#' | '-')* 
;

//terminal IDENTIFIER_FIRST_CHARACTER:
//	('a'..'z' | 'A'..'Z' | '_')
//;

//IdentifierConsecutiveCharacter:
//	IDENTIFIER_FIRST_CHARACTER | DIGIT | '$' | '#' | '-'
//;


Index:
	IntegerNumber // TODO: Maybe add word[XXX] 
;

CaseExpr:
	'case' CaseBody 'esac'
;

//CaseBody:
//	(BasicExpression ':' {BasicExpression.left=current} ';') {CaseBody.left=current}
//;


//Comment: 
//	comment = SMV_COMMENT
//;


// terminal AND_OR : '&' | '|' ;

VariablesSection: //@SM: possible sequence VAR -> ASSIGN -> VAR - no need to actually declare anything 
	'VAR'
	(variables += VariableDeclaration)*
;
	
Assignments:
	{Assignments}
	'ASSIGN'
	(assignments += AssignmentExpression)*
;

Transactions:
	'TRANS'
	(transaction += TransactionStatement)+
;

TransactionStatement:
	precondition = TransactionPrecondition '->' postTransaction = PostTransaction
;

TransactionPrecondition: 
	preconditions += PreconditionStatement 
	//preconditions += PreconditionStatement ( logicalOperator += AND_OR preconditions += PreconditionStatement)*  
;

PreconditionStatement:
	IntegerPrecondition | BooleanPrecondition | StatePrecondition
;

StatePrecondition:
	var = [StateVariableDeclaration] '=' value=IDENTIFIER
;

BooleanPrecondition:
	var = [BooleanDeclarion] '=' value=BOOL
;

IntegerPrecondition:
	var = [IntegerDeclarion] '=' value=INT
;

PostTransaction: 
	postTransactions += PostTransactionStatement 
	//( logicalOperator += AND_OR postTransactions += PostTransactionStatement )*
;

PostTransactionStatement:
	ConditionalPostTRansaction | SimplePostTransaction //| Comment
;

SimplePostTransaction:
	IntegerPostTransaction | BooleanPostTransaction | StatePostTransaction //| Comment 
;

StatePostTransaction:
	'next' '(' var = [StateVariableDeclaration] ')' '=' value = IDENTIFIER
;

BooleanPostTransaction:
	'next' '(' var = [BooleanDeclarion] ')' '=' value = BOOL
;

IntegerPostTransaction:
	'next' '(' var = [IntegerDeclarion] ')' '=' value = INT
;

ConditionalPostTRansaction:
	name = IDENTIFIER
;

IntegerDeclarion:
	name=IDENTIFIER ':' 'integer' ';'
;

BooleanDeclarion:
	name=IDENTIFIER ':' 'boolean' ';'
;

StateVariableDeclaration:
	name=IDENTIFIER ':' '{' states += IDENTIFIER (',' states += IDENTIFIER )* '}' ';'
;


//VarType: 
//	'boolean' | 'integer'
//;

//AssignmentExpression:
//	id = ComplexIdentifier ':=' expression = SimpleExpression |
//	InitAssignment | NextAssignment |
//	IntegerAssignment | BooleanAssignment | StateAssignment  | Comment
//;
//
//InitAssignment:
//	'init' '(' ComplexIdentifier ')' ':=' {SimpleExpression.assign2=current}
//;
//
//NextAssignment:
//	'next' '(' ComplexIdentifier ')' ':=' {BasicExpression.assign3=current}
//;

AssignmentExpression:
  SimpleAssign
  | InitAssign
  | NextAssign
;

SimpleAssign:
  id=ComplexIdentifier ':=' expression=SimpleExpression semicolon?=';'?
;

InitAssign:
  'init' '(' id+=IDENTIFIER ('.' id+=IDENTIFIER)*  ')' ':=' expression=SimpleExpression semicolon?=';'?
;



NextAssign:
  'next' '(' id+=IDENTIFIER ('.' id+=IDENTIFIER)* ')' ':=' expression=NextExpression semicolon?=';'?
;

NextExpression returns Expression:
  SimpleExpression
;

BooleanAssignment:
	'init' '(' var = [BooleanDeclarion] ')' ':=' value=BOOL ';'
;

BOOL:
	'TRUE' | 'FALSE'
;

IntegerAssignment:
	'init' '(' var = [IntegerDeclarion] ')' ':=' value=INT ';'
;

StateAssignment:
	'init' '(' var = [StateVariableDeclaration] ')' ':=' value=IDENTIFIER ';'
;

	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BasicExpression returns Expression:
  Implies;

// Shared by Basic, LTL, CTL
Implies returns Expression:
  Equivalence ({BinaryExpression.left=current} feature=OpImplies right=Equivalence)*; // TODO: operator precedence
  
OpImplies:
 '->';

// Shared by Basic, LTL, CTL
Equivalence returns Expression:
  IfThenElse ({BinaryExpression.left=current} feature=OpEquivalence right=IfThenElse)*;
  
OpEquivalence:
 '<->';
  
IfThenElse returns Expression:
  Or ({IfThenElse.left=current}'?' then=Or ':' else=Or)? //TODO: not sure if OR!!!!!! maybe unaryEX
;
  
Or returns Expression:
  And ({BinaryExpression.left=current} feature=OpOr right=And)*;

OpOr:
  'xnor' | '|' | 'xor';

And returns Expression:
  BasicRelational ({BinaryExpression.left=current} feature=OpAnd right=BasicRelational)*;
  
OpAnd:
  '&';
 
BasicRelational returns Expression:
  BasicIn ({BinaryExpression.left=current} feature=BasicOpRelational right=BasicIn)*;

BasicOpRelational:
  '=' | '!=' | '<' | '>' | '<=' | '>=';

BasicIn returns Expression:
  BasicUnion ({BinaryExpression.left=current} feature=BasicOpIn right=BasicUnion)*;

BasicOpIn:
 'in';
  
BasicUnion returns Expression:
  BasicShift ({BinaryExpression.left=current} feature=BasicOpUnion right=BasicShift)*;

BasicOpUnion:
 'union';

BasicShift returns Expression:
  BasicAddSub ({BinaryExpression.left=current} feature=BasicOpShift right=BasicAddSub)*;  

BasicOpShift:
  '<<'|'>>';

BasicAddSub returns Expression:
  BasicRemainder ({BinaryExpression.left=current} feature=BasicOpAddSub right=BasicRemainder)*;  

BasicOpAddSub:
  '+'|'-';

BasicRemainder returns Expression:
  UnaryMinusExpression ({BinaryExpression.left=current} feature=BasicOpRemainder right=UnaryMinusExpression)*;
  
BasicOpRemainder:
  'mod' | '*' | '/';  

UnaryMinusExpression returns Expression:
	BasicWordConcatenation | {UnaryMinusExpression} feature=BasicMinusOpUnary expression=UnaryMinusExpression
;

BasicMinusOpUnary:
	'-'
;

BasicWordConcatenation returns Expression:
   UnaryExclamationExpression ({BinaryExpression.left=current} feature=BasicOpWordConcatenation right=UnaryExclamationExpression)*;

BasicOpWordConcatenation:
  '::';
  
UnaryExclamationExpression returns Expression:
	UnaryExpression | {UnaryExclamationExpression} feature=BasicExclamationOpUnary expression=UnaryExclamationExpression
;

BasicExclamationOpUnary:
	'!'
;

//SetExpression:
//	IndexExpression | RangeExpression | CommaExpression
//;

//IndexExpression:
//	'[' INT ']'
//;
//
//RangeExpression:
//	'[' Range ']'
//;
//
//CommaExpression:
//	INT ',' INT
//;

UnaryExpression returns Expression:
	SimpleExpressionParenthesis | Case | BooleanConstant | SetBodyExpression | EnumIdentifier
	| Next | {Keywords} ('self' | 'running') 
;

Next returns Expression:
  {Next}
  'next' '(' expression=SimpleExpression ')'
;  

SimpleExpressionParenthesis returns Expression:
  '(' Implies {SimpleExpressionParenthesis.expression=current} ')'
;


EnumIdentifier:
	name += GeneralIdentifier ('.' name += GeneralIdentifier)*
;

GeneralIdentifier:
	INT | IDENTIFIER 
;


BooleanConstant returns Expression: 
  {BooleanConstant} 
  (isTrue?='TRUE'|'FALSE')
;

Case returns Expression:
  {Case}
  'case'
    (caseBodies+=CaseBody)+
  'esac'
;

CaseBody returns Expression:
  {CaseBody}
  case = SimpleExpression ':' assigment=SimpleExpression ';'
;

///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
//SPECS
//////////////////////////////////////////////////////////////////////////////////


LTLSpecification:
	'LTLSPEC' expression=LTLExpression ';'?
;

CTLSpecification:
	'CTLSPEC' CTLExpression ';'?
;

CTLExpression returns Expression:
	SpecImplies
;

LTLExpression returns Expression: 
	SpecImplies
;

SpecImplies returns Expression:
  SpecEquivalence ({BinaryExpression.left=current} feature=OpImplies right=SpecEquivalence)*
;
  
SpecEquivalence returns Expression:
  SpecOr ({BinaryExpression.left=current} feature=OpEquivalence right=SpecOr)*
;  
  
SpecOr returns Expression:
  SpecAnd ({BinaryExpression.left=current} feature=OpOr right=SpecAnd)*
;


SpecAnd returns Expression:
  Triggered ({BinaryExpression.left=current} feature=OpAnd right=Triggered)*;
  
  // LTL
Triggered returns Expression:
  Since ({BinaryExpression.left=current} feature=OpTriggered right=Since)*;
  
OpTriggered:
  'T';

// LTL
Since returns Expression:
  Releases ({BinaryExpression.left=current} feature=OpSince right=Releases)*;
  
OpSince:
  'S';

// LTL
Releases returns Expression:
  Until ({BinaryExpression.left=current} feature=OpReleases right=Until)*;

OpReleases:
  'V';

// LTL
Until returns Expression:
  SpecUnaryExpression ({BinaryExpression.left=current} feature=OpUntil right=SpecUnaryExpression)*;
  
OpUntil:
  'U';
  
SpecUnaryExpression returns Expression:
	ExistsUntil | ForallUntil | 
	{UnaryExpression} feature=OpSpecUnaryExpression expression=SpecUnaryExpression |
	Primary 
;

OpSpecUnaryExpression:
	'!' // Shared by Basic, LTL, CTL
	|'X'|'G'|'F'|'Y'|'Z'|'H'|'O' // LTL
	|'EG'|'EX'|'EF'|'AG'|'AX'|'AF' // CTL  	
;

//// CTL
// TODO thats to hacky, because we normally expect an Until expression, not a SimpleExpression  
ExistsUntil returns Expression:
  {ExistsUntil}
  'E' '[' expression=SimpleExpression ']';
    
//// CTL
// TODO thats to hacky, because we normally expect an Until expression, not a SimpleExpression
ForallUntil returns Expression:
  {ForallUntil}
  'A' '[' expression=SimpleExpression ']';

  
  
Primary returns Expression:
  Parenthesis
  | EnumAssignment
  | EnumIdentifier
  //| CaseType
  //| IntervallExpression
  //| ComplexIdentifier  // VariableIdentifier + DefineIdentifier
  //| BooleanConstant
  //| IntegerConstant  
  //| WordConstant  
;

EnumAssignment:
	var += IDENTIFIER ('.' var+= IDENTIFIER)* '=' var2 = (IDENTIFIER | BOOL)
;

//CaseType:
//	var=[Type]
//;

Parenthesis returns Expression:
  '(' SpecImplies {Parenthesis.expression=current} ')'
;

IntervallExpression returns Expression:
  {IntervallExpression}
  lower=INT '..' upper=INT
;


ComplexIdentifier returns Expression:
  ComplexIdentifierPrimary ({BinaryExpression.left=current} '.' right=ComplexIdentifierPrimary)*;
  

//superType:
//	DeclaredVariable | EnumVariable
//;

ComplexIdentifierPrimary returns Expression:  
  {VariableIdentifier} var=[Variable|IDENTIFIER] ('[' expression=SimpleExpression ']')?  
  | {PredefinedVariable} feature=('self'|'running')
;


// Referenceable Variables

Definition returns Variable:
  name=IDENTIFIER ':=' assignment=SimpleExpression semicolon?=';'?
;

Constant returns Variable:
  name=IDENTIFIER
;

DeclaredSimpleVariable returns Variable:
  name=IDENTIFIER ':' type=SimpleTypeSpecifier semicolon?=';'?
;

FormalParameter returns Variable:
  name=IDENTIFIER
;




// terminal WORD : '0' ('u'|'s')? ('b'|'B'|'o'|'O'|'d'|'D'|'h'|'H') (('1'..'9') ('0'..'9')*)? '_' ('0'..'9'|'a'..'f'|'A'..'F')+;
terminal SL_COMMENT : '--' !('\n'|'\r')* ('\r'? '\n')? ;
//terminal INT returns ecore::EInt: '-'? ('0'..'9')*;
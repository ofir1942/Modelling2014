/*
 * generated by Xtext
 */
package org.xtext.osy.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.xtext.osy.extendedSMV.Module
import javax.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.xtext.osy.extendedSMV.VariableDeclaration
import org.xtext.osy.extendedSMV.Assignments
import org.xtext.osy.extendedSMV.LTLSpecification
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.xtext.osy.extendedSMV.PatternsDefinitions
import java.io.FileOutputStream
import com.google.common.base.Charsets
import java.io.BufferedReader
import java.io.InputStreamReader
import org.xtext.osy.launch.Launch
import org.xtext.osy.extendedSMV.CTLSpecification
import org.xtext.osy.extendedSMV.Parameter

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
 
class ExtendedSMVGenerator implements IGenerator {
	@Inject extension IQualifiedNameProvider
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		var allCode = ""
		for(e: resource.allContents.toIterable.filter(Module)) {
			//var filePath = e.fullyQualifiedName.toString("/") + ".smv"
			allCode = allCode + '\n' + e.compile
		 	
	 	}
	 	
	 	fsa.generateFile( "code.smv",
	      					  allCode)
	}
	
	/**
	 * Xtend function to compile esmv MODULE
	 */
	def compile( Module m )
	{
		var code = "MODULE " + m.name +"("
		var containsParams = false // are there any parameters?
		for( p: m.params){
			if( p instanceof Parameter ){
				containsParams = true
				code = code + NodeModelUtils.getTokenText(NodeModelUtils.getNode(p)) + ","
			}
		}
		if(containsParams){
			code = code.substring(0, code.length-1) // removes the last comma which is not needed
		}
		code = code + ")\n"
		for( s: m.sections ) {
			if( s instanceof Assignments ){
				code = code + CompileAssignments( s )
			}
			else if( s instanceof VariableDeclaration )  {
				code = code + CompileVariables( s )
			}
			else if( s instanceof LTLSpecification ) {
				code = code + CompileLTLSpec( s )
			}
			else if( s instanceof CTLSpecification ) {
				code = code + CompileCTLSpec( s )
			}
			else if( s instanceof PatternsDefinitions ) {
				CompilePatterns( s )
			}
			else  {
				code = code + '\n' + NodeModelUtils.getTokenText(NodeModelUtils.getNode(s)) + '\n'
			}
		} 
		return code
	}
	
	/*
	 * Compile and save newly defined patterns
	 */
	def CompilePatterns(PatternsDefinitions definitions) {
		var patterns = NodeModelUtils.getTokenText(NodeModelUtils.getNode(definitions))
		patterns = patterns.replace( "PATTERNS", "")
		patterns = patterns.replace( ";", ";\n")
		
		var file = new FileOutputStream(  './macros.txt')
		file.write( patterns.getBytes( Charsets.UTF_8 ) )
		file.close()	
	}

	/*
	 * Compile LTL specifications. Replace "XXX" with the relevant pattern  
	 */
	def CompileLTLSpec(LTLSpecification specification) {
		var code = 'LTLSPEC '
		
		if( specification.expression != null )
		{
			code = code + NodeModelUtils.getTokenText(NodeModelUtils.getNode(specification.expression ))
		}
		
		for( p: specification.patterns ) {
			if( specification.expression != null )
			{	
				code = code + ' & '
			} 
			
			code = code + TranslatePattern( p )
		}
		code = code + '\n'
		return code 
	}
	
	/*
	 * Compile CTL specifications. Replace "XXX" with the relevant pattern  
	 */
	def CompileCTLSpec(CTLSpecification specification) {
		var code = 'CTLSPEC '
		
		if( specification.expression != null )
		{
			code = code + NodeModelUtils.getTokenText(NodeModelUtils.getNode(specification.expression ))
		}
		
		for( p: specification.patterns ) {
			if( specification.expression != null )
			{	
				code = code + ' & '
			} 
			
			code = code + TranslatePattern( p )
		}
		code = code + '\n'
		return code 
	}
	
	/*
	 * Translate pattern into the relevant specification
	 */
	def TranslatePattern(String pattern) {
		var pluginRootDir 	= class.protectionDomain.codeSource.location.file.substring(1) + "../"
		var macroParserPath = Launch.findFilePath(pluginRootDir, "MacroParser.py");
		var proc 			= Runtime.runtime.exec("python.exe "+ macroParserPath+" ./macros.txt " + pattern)
	
		var stream = new InputStreamReader(  proc.inputStream )
		var reader = new BufferedReader(stream)
		
		return reader.readLine()
	}

	/* 
	 * Compile ASSIGN section
	 */
	def CompileAssignments( Assignments assignments) {
		var code = NodeModelUtils.getTokenText(NodeModelUtils.getNode(assignments))
		code = code.replace( "ASSIGN", "ASSIGN\n")
		code = code.replace( ";", ";\n")
		
		return code
	}

	/* 
	 * Compile VAR section
	 */
	def CompileVariables( VariableDeclaration varsSection) {
		var code = NodeModelUtils.getTokenText(NodeModelUtils.getNode(varsSection))
		code = code.replace( "VAR", "VAR\n")
		code = code.replace( ";", ";\n")
		
		return code
	}
}
